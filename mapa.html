<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-tip/0.7.1/d3-tip.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.13.0/d3-legend.js"></script>

<style>
    svg rect {
        fill: white; /* map background colour */
    }

    .d3-tip {
        line-height: 1;
        padding: 12px;
        background: rgba(43, 43, 43, 0.8);
        color: #fff;
        border-radius: 2px;
    }
</style>


<!-- Create an element where the map will take place -->
<svg id="my_dataviz" class='legend' width="800" height="600"></svg>
<script>
    // The svg
    var svg = d3.select("svg"),
        width = +svg.attr("width"),
        height = +svg.attr("height");

    // Map and projection
    var path = d3.geoPath();
    var projection = d3.geoMercator()
        .scale(150000)
        .center([2.154007, 41.390205])
        .translate([width / 2, height / 2])
    ;

    // Data and color scale
    var data = d3.map();
    var colorScale = d3.scaleLinear()
        .domain([-20, 0, 100])
        .range(["green", "white", "red"]);

    var tip = d3.tip()
        .attr('class', 'd3-tip')
        .offset([-5, 0])
        .html(function (d) {
            var diff = d.properties.diff_mitjana
            if (diff) {
                return d.properties.NOM + ': ' + d.properties.diff_mitjana.toFixed(2) + '%'
            } else {
                return d.properties.NOM + ': ' + 'sense dades'
            }
        })

    function pisAString(d) {
        let diff_mitjana = parseFloat(d.diff_mitjana).toFixed(2);
        return `
            <strong>${diff_mitjana} sobre la mitjana</strong>
            <p>${d.building_subtype} ${d.sqft_m2} m²</p>
            <p>${d.rooms} habitacions</p>
            <p>${d.bathrooms} lavabos</p>
            <p>Amb ascensor? ${d.floor_elevator}</p>
            <p>Nova construcció? ${d.is_new_construction}</p>
            <p></p>
            <p>${d.realestate}</p>
            <p>${d.neighbourhood}</p>
            <p>${d.price} €/mes</p>
            <p>Descompte: ${d.discount} €/mes</p>
        `;


    }
    var tipCircle = d3.tip()
        .attr('class', 'd3-tip')
        .offset([-5, 0])
        .html(function (d) {
            return pisAString(d)
        })


    // Create function to apply zoom to countriesGroup
    function zoomed() {
        t = d3
            .event
            .transform
        ;
        barrisMap
            .attr("transform", "translate(" + [t.x, t.y] + ")scale(" + t.k + ")")
        ;
    }

    var path = d3
        .geoPath()
        .projection(projection)
    ;

    // zoom to show a bounding box, with optional additional padding as percentage of box size
    function boxZoom(box, centroid, paddingPerc, codiBarri) {
        minXY = box[0];
        maxXY = box[1];
        // find size of map area defined
        zoomWidth = Math.abs(minXY[0] - maxXY[0]);
        zoomHeight = Math.abs(minXY[1] - maxXY[1]);
        // find midpoint of map area defined
        zoomMidX = centroid[0];
        zoomMidY = centroid[1];
        // increase map area to include padding
        zoomWidth = zoomWidth * (1 + paddingPerc / 100);
        zoomHeight = zoomHeight * (1 + paddingPerc / 100);
        // find scale required for area to fill svg
        maxXscale = svg.attr('width') / zoomWidth;
        maxYscale = svg.attr('height') / zoomHeight;
        zoomScale = Math.min(maxXscale, maxYscale);
        // Find screen pixel equivalent once scaled
        offsetX = zoomScale * zoomMidX;
        offsetY = zoomScale * zoomMidY;
        // Find offset to centre, making sure no gap at left or top of holder
        dleft = Math.min(0, svg.attr('width') / 2 - offsetX);
        dtop = Math.min(0, svg.attr('height') / 2 - offsetY);
        // Make sure no gap at bottom or right of holder
        dleft = Math.max(svg.attr('width') - width * zoomScale, dleft);
        dtop = Math.max(svg.attr('height') - height * zoomScale, dtop);
        // set zoom
        svg
            .transition()
            .duration(500)
            .call(
                zoom.transform,
                d3.zoomIdentity.translate(dleft, dtop).scale(zoomScale)
            );

        d3.selectAll(".circle").attr("visibility", "hidden");
        d3.selectAll(".circle-"+parseInt(codiBarri)).attr("visibility", "visible");

    }


    // Define map zoom behaviour
    var zoom = d3
        .zoom()
        .on("zoom", zoomed)
    ;


    svg.call(tip);
    svg.call(tipCircle);

    svg.call(zoom)
    // Load external data and boot
    d3.queue()
        .defer(d3.json, "http://0.0.0.0:8000/barris_marcator.geojson")
        //.defer(d3.json, "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson")
        //  .defer(d3.csv, "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world_population.csv", function(d) { data.set(d.code, +d.pop); })
        .defer(d3.csv, "http://0.0.0.0:8000/data_final_id_clean.csv")
         .await(ready);

    function ready(error, topo, data) {


        barrisMap = svg.append("g").attr("id", "map");
        // add a background rectangle
        barrisMap
            .append("rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr('class', 'legend')
            .attr("width", width)
            .attr("height", height);

        // Draw the map
        barrisMap
            .selectAll("path")
            .data(topo.features)
            .enter()
            .append("path")
            // draw each country
            .attr("d", path
            )
            // set the color of each country
            .attr("fill", function (d) {
                if (!d.properties.diff_mitjana) {
                    return "black"
                }
                return colorScale(d.properties.diff_mitjana);
            })
            .on('mouseover', tip.show)
            .on('mouseout', tip.hide)
            .on("click", function (d, i) {
                boxZoom(path.bounds(d), path.centroid(d), 20, d.properties.CODI_UA);
            });

        barrisMap
            .selectAll("circle")
            .data(data)
            .enter()
            .append("circle")
            .attr('class', function (d) {
                return 'circle circle-'+parseInt(d.id_neighbourhood)
            })
            .attr("visibility", "hidden")
            .attr("cx", function(d) {
                return projection([d.longitude, d.latitude])[0];
            })
            .attr("cy", function(d) {
                return projection([d.longitude, d.latitude])[1];
            })
            .on('mouseover', tipCircle.show)
            .on('mouseout', tipCircle.hide)
            .attr("r", 1)
            .style("fill", function(d) {
                return colorScale(d.diff_mitjana)
            })

            .style("stroke", "gray")
            .style("stroke-width",0.1)
            .style("opacity", 0.75);


        var legend = d3.legendColor()
            .shapePadding(0)
            .orient("vertical")
            .labelAlign("start")
            .scale(colorScale);


        svg.append("g").attr("id", "legend").call(legend);

    }


</script>

